#!/usr/bin/env perl
# @author Robin Schneider <ypid23@aol.de>
# @licence GPLv3 <http://www.gnu.org/licenses/gpl.html>
#
# Convert all school holidays from schulferien.org (provided as ical) to a
# JSON definition which can be used inside the JavaScript library.

# my default preamble {{{
use strict;
use warnings;
use autodie;
use feature qw(say);
use utf8;
use open qw(:std :utf8);
binmode STDOUT, ':encoding(UTF-8)';

# }}}

# constant variables {{{
my $ical_overview_url = 'http://www.schulferien.org/iCal/';
my $tmp_dir_icals     = '/tmp/school_holiday_icals/';
my @only_states       = ( 'Baden-Württemberg', 'Bayern', 'Bremen' );

my @try_not_referenced_years = (0, 6);
# number is maximum years to try which are not referenced from the website.
# first number: years to go to past
# last number:  years to go into future
# schulferien.org is so kind and gives you an overview of the available files if one character is misspelled.
# http://www.schulferien.org/iCal/Ferien/icals/Ferien_Baden_Wuerttemberg_201x.ics
# }}}

# used libraries for this script {{{
use Data::ICal;
use Data::ICal::DateTime;
use DateTime;
use WWW::Mechanize;
use File::Path qw(make_path);
# }}}

# get the list of available school holidays {{{
my $mech = WWW::Mechanize->new();
$mech->get( $ical_overview_url );
my %ical_urls;
{
    my %first; # first valid defection per state
    my %last;  # last valid defection per state
    my @ical_urls_curr_state;
    for my $link ( $mech->links() ) {
        my $attrs    = $link->attrs();
        my $base     = $link->base();
        my $filename = $link->url();
        if ($filename =~ /\.ics\Z/xms
                && $attrs->{onmouseover} =~ /\('iCal\sSchulferien\s(?<year>\d{4})\s(?<state_name>[^']*)'\)/xms) {
            my $year       = $+{year};
            my $state_name = $+{state_name};
            $filename =~ /(?<start>\AFerien\/icals\/Ferien_)(?<save_state>[\w_-]+)_(?<year>\d{4})(?<end>\.ics)\Z/xms
                or die 'Could not get year';
            unless (defined $first{year}) {
                %first = ( year => $year, state_name => $state_name, save_state => $+{save_state} );
            }
            if (defined $last{year} and $last{year} > $year) {
                if ($try_not_referenced_years[0]) {
                    for my $try_year (reverse $first{year} - $try_not_referenced_years[0] .. $first{year} - 1) {
                        unshift(@ical_urls_curr_state, [ $+{start} . $first{save_state} . '_' . $try_year . $+{end}, $try_year ]);
                    }
                }
                if ($try_not_referenced_years[1]) {
                    # add not referenced years
                    for my $try_year ($last{year} + 1 .. $last{year} + $try_not_referenced_years[1]) {
                        push(@ical_urls_curr_state, [ $+{start} . $last{save_state} . '_' . $try_year . $+{end}, $try_year ]);
                    }
                }
                $ical_urls{$last{state_name}} = [ @ical_urls_curr_state ];
                @ical_urls_curr_state = ();
                %first = ( year => $year, state_name => $state_name, save_state => $+{save_state} );
            }
            push(@ical_urls_curr_state, [ $filename, $year ]);
            %last = ( year => $year, state_name => $state_name, save_state => $+{save_state} );
        }
    }
    $ical_urls_curr_state[-1][0] =~ /(?<start>\AFerien\/icals\/Ferien_)(?<save_state>[\w_-]+)_(?<year>\d{4})(?<end>\.ics)\Z/xms
        or die 'Could not get year';

    if ($try_not_referenced_years[0]) {
        for my $try_year (reverse $first{year} - $try_not_referenced_years[0] .. $first{year} - 1) {
            unshift(@ical_urls_curr_state, [ $+{start} . $first{save_state} . '_' . $try_year . $+{end}, $try_year ]);
        }
    }
    for my $try_year ($last{year} + 1 .. $last{year} + $try_not_referenced_years[1]) {
        push(@ical_urls_curr_state, [ $+{start} . $last{save_state} . '_' . $try_year . $+{end}, $try_year ]);
    }
    $ical_urls{$last{state_name}} = [ @ical_urls_curr_state ];
}
# }}}

# debugging stuff {{{
# use Data::Dumper::Simple;
# my %ical_urls = (
#     'Bremen' => [
#         [
#             'Ferien/icals/Ferien_Bremen_2012.ics',
#             2012
#         ],
#         [
#             'Ferien/icals/Ferien_Bremen_2013.ics',
#             2013
#         ],
#     ],
#     'Bayern' => [
#         [
#             'Ferien/icals/Ferien_Bayern_2012.ics',
#             2012
#         ],
#         [
#             'Ferien/icals/Ferien_Bayern_2013.ics',
#             2013
#         ],
#     ],
#     'Baden-Württemberg' => [
#         [
#             'Ferien/icals/Ferien_Baden_Wuerttemberg_2013.ics',
#             2013
#         ],
#         [
#             'Ferien/icals/Ferien_Baden_Wuerttemberg_2014.ics',
#             2014
#         ],
#     ],
# );
# say Dumper %ical_urls;
# exit(2);
# }}}

# input loop (creates the final hash) {{{
my %final;
my %only_states = map { $_ => 1 } @only_states;
make_path $tmp_dir_icals;

FILE:
for my $state_name (keys %ical_urls) {

    HOLIDAY_FOR_STATE:
    for my $link_arr (@{$ical_urls{$state_name}}) {
        my $filename   = $link_arr->[0];
        my $year       = $link_arr->[1];
        unless ($only_states{$state_name}) {
            next FILE;
        }

        $filename =~ /\AFerien\/icals\/Ferien_(?<state>[\w_-]+)_(?<year>\d{4})\.ics\Z/xms
            or die 'Could not get year';
        # $+{state} is the save version (without Unicode characters and hyphens)
        my $curr_ical_file = $tmp_dir_icals . $+{state} . '_' . $+{year} . '.ics';

        unless (-e $curr_ical_file) {
            my $response = $mech->get( $ical_overview_url . $filename, ':content_file' => $curr_ical_file );
            unless ($response->is_success) {
                last HOLIDAY_FOR_STATE;
            }
        }

        my $cal = Data::ICal->new(filename => $curr_ical_file);
        my @events = $cal->events();

        my $pos = -1;
        my $last_holiday_name;

        HOLIDAY_THIS_YEAR: # ical is actually sorted, don’t know why this is unsorted but I rely on it
        foreach my $event (sort { $a->start cmp $b->start} @events) {
            $pos++;

            my $ends_next_year = $event->start->year != $event->end->year;
            my $holiday_name   = $event->property('summary')->[0]->value;
            $holiday_name =~ s/\s[\w_-]+\z//xms; # remove state name

            my @date_range = ($event->start->month, $event->start->day, $event->end->month, $event->end->day);

            if (defined $final{$state_name}) {
                my $count = -1;
                for my $holiday (@{$final{$state_name}}) { # go through all holidays for state
                    $count++;
                    if ($holiday->{name} eq $holiday_name) {

                        if ($event->start->month == 1 and $event->start->day == 1) {
                            if (defined $holiday->{$event->start->year - 1}
                                    and $pos == 0) {
                                # this is the part spanning the year # 2013: [ 1, 1, 1, 5 ],
                                # Modify last year …
                                $holiday->{$event->start->year - 1}->[-1]->[2] = $event->end->month;
                                $holiday->{$event->start->year - 1}->[-1]->[3] = $event->end->day;
                                $last_holiday_name = $holiday_name;
                                next HOLIDAY_THIS_YEAR;
                            }
                        }

                        # year already existing?
                        if (defined $holiday->{$event->start->year}) {
                            if ($last_holiday_name eq $holiday_name) {
                                # The current holiday is defined multiple times
                                # e.g. from 04-15 to 04-20 and 04-24 to 04-27

                                push($final{$state_name}->[$count]->{$event->start->year}, [ @date_range ]);
                                $last_holiday_name = $holiday_name;
                                next HOLIDAY_THIS_YEAR;
                            } else {

                            my $holiday_ref = $holiday->{$event->start->year};
                            # say Dumper $holiday_ref;
                            die "$holiday_name for $year in $state_name does already exist."
                                . " This script needs fixing :-("
                            }
                        }

                        $holiday->{$event->start->year} = [ \@date_range ];
                        $last_holiday_name = $holiday_name;
                        next HOLIDAY_THIS_YEAR;
                    }
                }
            }

            # this part is spanning the year # 2013: [ 1, 1, 1, 5 ],
            if ($event->start->month == 1 and $event->start->day == 1 and $pos == 0) {
                    # There is no previous year ignore this holiday.
                    next HOLIDAY_THIS_YEAR;
            }

            if (defined $final{$state_name}) {
                push($final{$state_name}, { name => $holiday_name, $event->start->year => [ \@date_range ], pos => $pos });
            } else {
                $final{$state_name}   = [ { name => $holiday_name, $event->start->year => [ \@date_range ], pos => $pos } ];
            }
            $last_holiday_name = $holiday_name;
        }
    }
}
# }}}

# output loop (formats the content of the final hash as JSON) {{{
# say Dumper %final;
for my $state_name (keys %final) {
    my $indent_level = 0;
    say q( ) x $indent_level . qq('$state_name': {);
    $indent_level += 4;
    say q( ) x $indent_level . qq('SH': [);

    $indent_level += 4;
    for my $holiday (sort {$a->{pos} cmp $b->{pos}} @{$final{$state_name}}) {
        say q( ) x $indent_level . '{';
        say q( ) x $indent_level . qq(    name: '$holiday->{name}',);
        $indent_level += 4;
        for my $year (sort keys $holiday) {
            if ($year ne 'name' and $year ne 'pos') {
                my $count_range = 0;
                print q( ) x $indent_level . $year . ': [ ';
                for my $date_range (@{$holiday->{$year}}) {
                    $count_range++;
                    if ($count_range > 1) {
                        print ',  ';
                    }
                    print sprintf('%2d, %2d', $date_range->[0], $date_range->[1]) . ', /* to */ '
                        . sprintf('%2d, %2d', $date_range->[2], $date_range->[3]);
                }
                say ' ],';
            }
        }
        $indent_level -= 4;
        say q( ) x $indent_level . qq(},);
    }
    $indent_level -= 4;
    say q( ) x $indent_level . qq(],);
    $indent_level -= 4;
    say q( ) x $indent_level . qq(},);
}
# }}}
